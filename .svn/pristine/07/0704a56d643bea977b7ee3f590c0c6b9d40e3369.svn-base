package bd.nmam.collection.business.handler.beidian;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.net.InetSocketAddress;
import java.util.List;

import bd.nmam.collection.business.pojo.beidian.DeviceCommandPojo;
import bd.nmam.collection.util.beidian.ContainerUtil;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.socket.DatagramPacket;

public class BeidianUDPTimeCalibrationHandler extends ChannelInboundHandlerAdapter{
	private final String TYPE_TIMECALIBRATION = "13";
	private String deviceId;
	@Override
	public void channelRead(ChannelHandlerContext ctx, Object msg)
			throws Exception {
		String data = (String)msg;
		Logger.getLogger("r3").info(data);
		String[] datas = data.split("####");
		switch (datas[1].substring(8, 10)) {
		case TYPE_TIMECALIBRATION:
			System.out.println("时钟校准指令 " + data);
			ByteBuf deviceResponse = Unpooled.copiedBuffer(ContainerUtil
					.TimeCalibration(datas[1]));
			String[] addr = datas[0].split(":");
			DatagramPacket dp = new DatagramPacket(deviceResponse,
					new InetSocketAddress(addr[0], Integer.parseInt(addr[1])));
			ctx.writeAndFlush(dp);
			Logger.getLogger("r3").info(datas[1]);
			Thread.sleep(1000);
			//缓存指令下发
			deviceId = datas[1].substring(16, 32);
			DeviceCommandPojo dcp = ContainerUtil.getDeviceCommBuf().get(deviceId);
			if(dcp!=null){
				dcp.setAddress(addr[0]);
				dcp.setPort(addr[1]);
				//==================================================
				List<String> index = dcp.get_INDEX();
				List<String> cmd = dcp.get_CMD();
				System.out.println("wwwwxxxx1");
				for(int i = 0; i < index.size(); i++){
					System.out.println("wwwwxxxx3 " + i);
					String[] _index = index.get(i).split("#");
					System.out.println(i + " " + _index[2] + " " + _index[3] + " " + _index[0]);
					if(_index[2].equals("0") && !_index[3].equals(_index[0])){
						System.out.println("send 4");
						byte[] data1 = ContainerUtil.message2Bytes(cmd.get(i));
						ByteBuf deviceCMD = Unpooled.copiedBuffer(data1);
						DatagramPacket dpCMD = new DatagramPacket(deviceCMD,
								new InetSocketAddress(addr[0], Integer.parseInt(addr[1])));
						ctx.writeAndFlush(dpCMD);
						index.set(i, _index[0] + "#" + (Integer.parseInt(_index[1]) + 1) + "#" + _index[2] + "#" + _index[3]);
						break;//设备端接收能力有限，发送一帧缓存指令后，中断发送循环
					}
				}
			}
			break;
		default:
			ctx.fireChannelRead(msg);
			break;
		}
	}
	
	@Override
	public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
		// TODO Auto-generated method stub
		// super.channelReadComplete(ctx);
	}
	
	@Override
	public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
			throws Exception {
		// TODO Auto-generated method stub
		// super.exceptionCaught(ctx, cause);
		cause.printStackTrace();
		StringWriter sw = new StringWriter();
		cause.printStackTrace(new PrintWriter(sw));
		ContainerUtil.getLoggerWrite().error(sw.toString());
	}
}
