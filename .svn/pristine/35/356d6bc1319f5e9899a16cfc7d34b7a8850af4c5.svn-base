package bd.nmam.collection.business.handler.beidian;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.net.InetSocketAddress;
import java.util.List;

import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.protocol.HTTP;

import bd.nmam.collection.business.pojo.beidian.DeviceCommandPojo;
import bd.nmam.collection.business.pojo.beidian.Upload;
import bd.nmam.collection.util.beidian.ContainerUtil;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.socket.DatagramPacket;
import net.sf.json.JSONObject;

public class BeidianUDPCtrlResponseHandler extends ChannelInboundHandlerAdapter{
	private static final String TYPE_RESPONSE_CONTROL = "8C";
	private String data;
	private String deviceId;
	private String SEQ;

	@Override
	public void channelRead(ChannelHandlerContext ctx, Object msg)
			throws Exception {
		// TODO Auto-generated method stub
		// super.channelRead(ctx, msg);
		data = (String) msg;
		Logger.getLogger("r3").info(data);
		String[] datas = data.split("####");
		switch (datas[1].substring(8, 10)) {
		case TYPE_RESPONSE_CONTROL:
			System.out.println("控制返回" + data);
			operate(datas[1]);
			ByteBuf deviceResponse = Unpooled.copiedBuffer(ContainerUtil
					.report(datas[1]));
			String[] addr = datas[0].split(":");
			DatagramPacket dp = new DatagramPacket(deviceResponse,
					new InetSocketAddress(addr[0], Integer.parseInt(addr[1])));
			// ctx.writeAndFlush(dp);
			// System.out.println("报警" + data);
			// new BeidianAlarm2WebThread(data).start();
			Thread.sleep(1000);
			//缓存指令下发
			deviceId = datas[1].substring(16, 32);
			//==================================================
			DeviceCommandPojo dcp = ContainerUtil.getDeviceCommBuf().get(deviceId);
			if(dcp!=null){
			dcp.setAddress(addr[0]);
			dcp.setPort(addr[1]);
			List<String> index = dcp.get_INDEX();
			List<String> cmd = dcp.get_CMD();
			for(int i = 0; i < index.size(); i++){
				String[] _index = index.get(i).split("#");
				if(SEQ.equals(_index[0])){
					index.set(i, _index[0] + "#" + _index[1] + "#" + (Integer.parseInt(_index[2]) + 1) + "#" + SEQ);
				}
			}
			for(int i = 0; i < index.size(); i++){
				String[] _index = index.get(i).split("#");
//				System.out.println(i + " ---->>>>>>--- " + index.get(i));
				
				if(_index[2].equals("0") && !_index[3].equals(_index[0])){
					System.out.println("send 3");
//					System.out.println(i + " ---->>>>>>---xxx " + index.get(i));
					byte[] data = ContainerUtil.message2Bytes(cmd.get(i));
					ByteBuf deviceCMD = Unpooled.copiedBuffer(data);
					DatagramPacket dpCMD = new DatagramPacket(deviceCMD,
							new InetSocketAddress(addr[0], Integer.parseInt(addr[1])));
					ctx.writeAndFlush(dpCMD);
					index.set(i, _index[0] + "#" + (Integer.parseInt(_index[1]) + 1) + "#" + _index[2] + "#" + _index[3]);
					break;//设备端接收能力有限，发送一帧缓存指令后，中断发送循环
				}
			}
			//==================================================
//			DeviceCommandPojo dcp = ContainerUtil.getDeviceCommBuf().get(deviceId);
//			if(dcp!=null && dcp.getCMD()!=null && dcp.getIssueFlag()==1){
//				String CMD = dcp.getCMD();
//				byte[] cmd = ContainerUtil.message2Bytes(CMD);
//				ByteBuf deviceCMD = Unpooled.copiedBuffer(cmd);
//				DatagramPacket dpCMD = new DatagramPacket(deviceCMD,
//					new InetSocketAddress(addr[0], Integer.parseInt(addr[1])));
//				ctx.writeAndFlush(dpCMD);
//			}
			}
			break;
		default:
			ctx.fireChannelRead(msg);
			break;
		}
	}

	private void operate(String data) {
		// TODO Auto-generated method stub
		try {
			String DeviceID = data.substring(16, 32);
			//============================================================
			boolean flag = false;
			SEQ = data.substring(data.length()-10, data.length()-6);
			DeviceCommandPojo dcp = ContainerUtil.getDeviceCommBuf().get(DeviceID);
			List<String> index = dcp.get_INDEX();
			for(int i = 0; i < index.size(); i++){
				String[] _index = index.get(i).split("#");
				System.out.println(i + "--1  " + index.get(i));
				if(_index[0].equals(SEQ) && Integer.parseInt(_index[1]) > 0 && _index[2].equals("0")){
					index.set(i, _index[0] + "#" + Integer.parseInt(_index[1]) + "#" + (Integer.parseInt(_index[2]) + 1) + "#" + SEQ);
					flag = true;
					break;
				}
				System.out.println("--2  " + index.get(i));
			}
			//============================================================
			if (ContainerUtil.checkSUM(data) && flag) {
				// Thread.sleep(50);
				// 数据拼接开始
				Upload ul = new Upload();
				ul.setPlatformID("xxxxxxxx");
				ul.setFrameType("ctrl_ack");
				ul.setDeviceID(DeviceID);
				ul.setStatus("success");

				JSONObject obj = JSONObject.fromObject(ul);

				HttpPost httpPost = new HttpPost(ContainerUtil.getResponseUrl());
				httpPost.addHeader(HTTP.CONTENT_TYPE, "application/json");
				StringEntity se = new StringEntity(obj.toString());
				httpPost.setEntity(se);
				CloseableHttpResponse rv = ContainerUtil.getHttpClient()
						.execute(httpPost);
				rv.close();
			} else {
				System.out.println(DeviceID + "设备控制返回指令校验失败");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Override
	public void channelActive(ChannelHandlerContext ctx) throws Exception {
		// TODO Auto-generated method stub
		// super.channelActive(ctx);
		// ContainerUtil.getTcpClientFuture().put(
		// ctx.channel().remoteAddress().toString().substring(1),
		// ctx.channel());
		ctx.fireChannelActive();
	}

	@Override
	public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
		// TODO Auto-generated method stub
		// super.channelReadComplete(ctx);
	}

	@Override
	public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
			throws Exception {
		// TODO Auto-generated method stub
		// super.exceptionCaught(ctx, cause);
		cause.printStackTrace();
		StringWriter sw = new StringWriter();
		cause.printStackTrace(new PrintWriter(sw));
		ContainerUtil.getLoggerWrite().error(sw.toString());
	}
}
